<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/league.css">

	<style>
		.webrtc-logo-img {
			background: unset !important;
			border: unset !important;
			box-shadow: unset !important;
			width: 100% !important;
		}

		.no-caps {
			text-transform: none !important;
		}
	</style>

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>
					The unstoppable secret superpower of WebRTC
					</h3>
					<h3>
						Jan Greger Hemb
					</h3>
					<h4>
						Senior knowledge engineer at Computas
					</h4>
			</section>
			<section>
				<img class="webrtc-logo-img" src="media/webrtc-logo-horiz-retro-dist.svg">
				<h2 class="no-caps fragment fade-right">Featuring the unstobbable Data Channel!</h2>
			</section>
			<section>Outline?</section>
			<section>
				<h2 class="no-caps">You don't need to know WebRTC</h2>
			</section>
			<section>
				<section>
					<h2>What is WebRTC in a nutshell?</h2>
					<ul>
						<li class="fragment">Direct browser to browser video, audio and data communication API</li>
						<li class="fragment">API for real time communication</li>
						<li class="fragment">Websocet directly between browsers</li>
						<li class="fragment">Channels for video, audio and data</li>
						<li class="fragment">Media engine</li>
					</ul>
				</section>
				<section>
					<h2>Traditional model</h2>
					<h3>A server in the middle</h3>
					ADD IMG!
				</section>
				<section>
					<h2>Skip the middle man!</h2>
					<h3>Communicate directly</h3>
					<aside class="notes" data-markdown>
						-Cutting the middle man is what amazon is doing
					</aside>
				</section>
				<section>
					Two browser can NOT contact each other directly. Need a signnaling server, but just for etablishing connectin
				</section>
			</section>
			<section>
				Too few developers know WebRTC as the learning curve is a bit steep in the beginning
				<aside class="notes" data-markdown>
					- Also is seems to be narrovly focues (just video conversations), but i'm here to prove thats wrong
				</aside>
			</section>
			<section>
				<section>
					How I learned WebRTC
					<aside class="notes" data-markdown>
						TODO add story notes
					</aside>
				</section>
			</section>
			<section>
				<section>
					Demo!
					<aside class="notes" data-markdown>
						Drawing app. simple code and what it does. backend just pering as people connect.
					</aside>
				</section>
				<section>
					Frontend in Angular and backend in NodeJS
				</section>
				<section>
					Code on github, can run all locally
				</section>
			</section>
			<section>
				<section>
					Creating the demo and prez was hard due to a dark force...
				</section>
				<section>
					Img Pondus x3
				</section>
			</section>
			<section>
				<section>
					How does WebRTC work? (theory, not code?)
				</section>
				<section>
					Getting media...
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						navigator.mediaDevices.getUserMedia({ video: true, audio: false })
						.then(function(mediaStream) {
							var video = document.querySelector('video');
							video.srcObject = mediaStream;
						}
					</code></pre>
				</section>
				<section>
					Setup RTCPeerConnection with a STUN server
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						const myRtcConnection = new RTCPeerConnection(configuration);
					</code></pre>
					<aside class="notes" data-markdown>
						-STUN is used for finding your public IP and port for establishing a connection
					</aside>
				</section>
				<section>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						const options = {
							reliable:true
						};
						const myDataChannel = myRtcConnection.createDataChannel("label", options)
						myRtcConnection.ondatachannel = (event) => {
							const receiveChannel = event.channel;
							receiveChannel.onmessage = (event) => {
								// got a message
							}
						}
					</code></pre>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myDataChannel.send( "Some data" );
					</code></pre>
				</section>
				<section>
					<h2>Connecting to another browser</h2>
					<p class="fragment">Need to meed at a signaling server</p>
					<p class="fragment">Does not tecnically need a signaling server</p>
					<p class="fragment">Can use some pidgeon with a memory stick</p>
					<p class="fragment">Suggest using WebSocket</p>
				</section>
				<section>
					Call some user connected to the same backend
					<p class="fragment">
						Create and send an offer (RTCSessionDescription)
					</p>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.createOffer().then(offer => {
							sendMessageToServer(offer, "User B");
							myRtcConnection.setLocalDescription(offer);
						}
					</code></pre>
					<aside class="notes" data-markdown>
						- A description of who you are, and what you support (your browser)
					</aside>
				</section>
				<section>
					The other user then receives this from the backend and creates an answer (RTCSessionDescription)
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.setRemoteDescription(offer);
						myRtcConnection.createAnswer((answer) => {
							sendMessageToServer(answer, "User A");
							myRtcConnection.setLocalDescription(answer);
						}
					</code></pre>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// on caller's side
						myRtcConnection.setRemoteDescription(answer);
					</code></pre>
				</section>
				<section>
					Then a series of ICE candiates are sent back and forth (RTCIceCandidate)
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.onicecandidate = (event) => {
							sendMessageToServer(event.candidate, "Other User");
						}
						// on the other client:
						myRtcConnection.addIceCandidate(new RTCIceCandidate(candidate))
					</code></pre>
					<aside class="notes" data-markdown>
						- For finding the shortest path between your two computers
						- Interactive Connectivity Establishment (ICE)
					</aside>
				</section>
				<section>
					Then each client attempts to connect to each other
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// Automagick
					</code></pre>
					<p class="fragment">
						Might fall back to TURN
					</p>
				</section>
				<section>
					Video conversation etc...
				</section>
				<section>
					<h2>
						Summary
					</h2>
					<ol>
						<li class="fragment">
							Shared backend
						</li>
						<li class="fragment">
							Video, sound, data
						</li>
						<li class="fragment">
							CreatePeerConnection with STUN (local)
						</li>
						<li class="fragment">
							Send offer, and receive answer
						</li>
						<li class="fragment">
							ICE candidates for mapping the network
						</li>
						<li class="fragment">
							Maybe fall back to TURN
						</li>
					</ol>
					<h2 class="fragment">
						Connected!
					</h2>
				</section>
			</section>
			<section>
				<section>
					The data channel
				</section>
				<section>
					Can send almost anything
				</section>
				<section>
					<h2>Examples</h2>
					<ul>
						<li class="fragment">Sending chat</li>
						<li class="fragment">Sending files</li>
						<li class="fragment">Sending state (game, redux, drawing, ...)</li>
						<li class="fragment">Sending screen</li>
						<li class="fragment">CDN</li>
					</ul>
				</section>
				<section>
					And no premission required (sidenote about safari)
				</section>
			</section>
			<section>
				<section>
					Let's dive into a few examples
				</section>
				<section>
					Sending chat
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// sender
						myDataChannel.send("Hello");

						// on the receiving side
						this.myRtcConnection.ondatachannel = (event) => {
							receiveChannel.onmessage = (message) => {
								// Display message
							};
						};
					</code></pre>
				</section>
				<section>
					Sending files (mention br3eaking up big files)
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// sender
						const fileReader = new FileReader();
						const fileSlice = file.slice(offset, offset + chunckSize);
						fileReader.readAsArrayBuffer(fileSlice);
						fileReader.onload = (event) => {
							this.myDataChannel.send(event.target.result);
						}

						// on the receiving side
						incommingFileBuffer.push(arrayBuffer);

						// when done on the receiving side
						var recivedFile = new Blob(this.incommingFileBuffer); 
					</code></pre>
				</section>
				<section>
					Sharing screen (unconfirmed API)
					Might be getting it like we get user media
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						navigator.mediaDevices.getUserMedia({ screen: true })
						.then(function(mediaStream) {
							...
						}
					</code></pre>
				</section>
				<section>
					Sharing a game state (drawing app)
				</section>
			</section>
			<section>
				<section>
					Large Data Channel Messages
				</section>
				<section>
					EOR<br>
					End Of Record<br>
					Is the message complete, or partial?
					<aside class="notes" data-markdown>
						- Chromium ignores that flag and simply delivers the incomplete message
						- Partial ways arout it
					</aside>
				</section>
				<section>
					"Thanks to the new EOR feature Firefox now supports receiving up to 1 GiB messages."
					<aside class="notes" data-markdown>
						- was less than 64 KiB
						- Got unstable around here, suddenly closing the connection, or blocking all other data
						- Firefox is now ahead of Chrome
					</aside>
				</section>
				<section>
					Not higher as the entire object needs to fit into memory and 1gb is starting to become to high for some devices due to low ram
					<aside class="notes" data-markdown>
						And larger messages are easilier lost in transmission (and at a higher cost)
					</aside>
				</section>
				<section>
					Is backward compatiable
				</section>
			</section>
			<section>
				<section>
					Just a few short ideas, there are MANY more usecases for sending data directly bvetween one or more browsers
				</section>
				<section>
					Got sad when you relised that the broadcast API is limited to a browser? <br>
					Use the data channel to link up more web browser on the same machene!
				</section>
				<section>
					Allow you to view this prez live on nour phone as i present? WEBRTC!
				</section>
				<section>
					Offloading data transmition to the frontend
					<br>
					Servers are (relativly) expencive
					<br>
					Using WebRTC offloads a lot of bandwith off the server
					<aside class="notes" data-markdown>
						- Can do far bigger, faster and more reliable data transfers between clients as server is not overloaded
					</aside>
				</section>
				<section>
					(call to action)<br>
					Webrtc is a buldingblock for the web of tomorrow. You will need it, either for video or data, or both. <br>
					We are aproaching av ever more connected future and WebRTC will help create that future
				</section>
				<section>
					Remember, it's gratis
				</section>
			</section>
			<section>
				<section>
					<h3>Browser support</h3>
					<iframe style="width: 700px; height: 580px;" src="https://caniuse.com/#search=webrtc"></iframe>
					<aside class="notes" data-markdown>
						- Edge does not have the data channel

						- "Microsof is unhappy with the state of WebRTC and wants a bigger standard (Object RTC )"
						- MS wants more control
					</aside>
				</section>
				<section>
					Safari and all the bugs
				</section>
			</section>
			<section>
				<section>
					<h2>Security</h2>
					Don't bother, its really good (inlude screenshot)<br>
					The alternatives are less ecure

					<aside class="notes" data-markdown>
						- "As a result of this strong focus on secure communication, WebRTC is currently regarded by some to be one of
						the
						most secure VoIP solutions out there"

						- WebRTC forbids unencrypted communication
					</aside>
				</section>
				<section>
					Webrtc and STUN gets your public IP. is that bad?
				</section>
			</section>
			<section>
				Consider using WebRTC adapter (github.com/webrtchacks/adapter)
			</section>
			<section>
				<section>
					News in WebRTC
				</section>
				<section>
					WebRTC is a Candidate Recommendation (CR)! (21 June 2018)<br>
					Means it started to stabilise and will se wider and better support
				</section>
				<section>
					Transceiver <br>
					New (and optional) way of having more control over how media flows between clients<br>
					More control for more complexity
					Don't learn it utill you master the standard (and easie) way
					(as far as i know) it will remain optional and not become the standard
				</section>
				<section>
					AddStream is replaced by AddTrack as WebRTC now support multible streams (video/audio) from each user<br>
					Data channel has always supported multible, but they could force sending in sequence on  large messages
				</section>
			</section>
			<section>
				Questions
			</section>
			<section>
				This page is unintentionally left blank
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			history: true,
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>