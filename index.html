<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/league.css">

	<style>
		.webrtc-logo-img {
			background: unset !important;
			border: unset !important;
			box-shadow: unset !important;
			width: 100% !important;
		}

		.no-caps {
			text-transform: none !important;
		}

		.contain-bg-img div {
			background-size: contain !important;
		}

		.slides {
			width: 80% !important;
		}
	</style>

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h2>
					The unstoppable secret superpower of WebRTC
					</h3>
					<h3>
						Jan Greger Hemb
					</h3>
					<h4>
						Senior knowledge engineer at Computas
					</h4>
			</section>
			<section>
				<img class="webrtc-logo-img" src="media/webrtc-logo-horiz-retro-dist.svg">
				<h2 class="no-caps fragment fade-right">Featuring the unstobbable Data Channel!</h2>
			</section>
			<section>
				<h2 class="no-caps">You don't need to know WebRTC</h2>
			</section>
			<section>
				<h3>The journey to to data channel</h3>
				<ul>
					<li class="fragment">Basic WebRTC</li>
					<li class="fragment">Story and demo</li>
					<li class="fragment">Connecting users</li>
					<li class="fragment">The Data channel</li>
					<li class="fragment">News</li>
					<li class="fragment">Browser support</li>
					<li class="fragment">Call to action</li>
				</ul>
			</section>
			<section>
				<section>
					<h2>What is WebRTC in a nutshell?</h2>
					<ul>
						<li class="fragment">Direct browser to browser communication API</li>
						<li class="fragment">API for real time communication</li>
						<li class="fragment">Websocet directly between browsers</li>
						<li class="fragment">Channels for video, audio and data</li>
						<li class="fragment">Media engine</li>
						<li class="fragment">API for making skype in the browser</li>
					</ul>
				</section>
				<section>
					<h3>Traditional model</h3>
					<h5>A server in the middle</h5>
					<img class="stretch" data-src="media/csm.png">
				</section>
				<section>
					<h3>Skip the middle man!</h3>
					<h5>Communicate directly</h5>
					<img class="stretch" data-src="media/p2p.png">
					<aside class="notes" data-markdown>
						-Cutting the middle man is what amazon is doing
					</aside>
				</section>
				<section>
					<h3>Two browser can NOT contact each other directly</h3>
					Need a signnaling server
				</section>
			</section>
			<section>
				Too few developers know WebRTC as the learning curve is a bit steep in the beginning
				Img of "eve online lerning curve"?
				<aside class="notes" data-markdown>
					- Also is seems to be narrovly focues (just video conversations), but i'm here to prove thats wrong
				</aside>
			</section>
			<section>
				<section>
					Creating the demo and prez was hard due to a dark force...
				</section>
				<section class="contain-bg-img" data-background="media/pondus/1.jpg"></section>
				<section class="contain-bg-img" data-background="media/pondus/2.jpg"></section>
				<section class="contain-bg-img" data-background="media/pondus/3.jpg"></section>
				<section class="contain-bg-img" data-background="media/pondus/4.jpg"></section>
				<section class="contain-bg-img" data-background="media/pondus/5.jpg"></section>
			</section>
			<section>
				<section>
					How I learned WebRTC
					<aside class="notes" data-markdown>
						TODO add story notes
					</aside>
				</section>
			</section>
			<section>
				<section>
					Demo!
					<aside class="notes" data-markdown>
						Drawing app. simple code and what it does. backend just pering as people connect.
					</aside>
				</section>
				<section>
					Frontend in Angular and backend in NodeJS
				</section>
				<section>
					Code on github, can run all locally
				</section>
			</section>
			<section>
				<section>
					How does WebRTC work? (theory, not code?)
				</section>
				<section>
					Getting media...
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						navigator.mediaDevices.getUserMedia({ video: true, audio: false })
						.then(function(mediaStream) {
							var video = document.querySelector('video');
							video.srcObject = mediaStream;
						}
					</code></pre>
				</section>
				<section>
					Setup RTCPeerConnection with a STUN server
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						const myRtcConnection = new RTCPeerConnection(configuration);
					</code></pre>
					<aside class="notes" data-markdown>
						-STUN is used for finding your public IP and port for establishing a connection
					</aside>
				</section>
				<section>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						const options = {
							reliable:true
						};
						const myDataChannel = myRtcConnection.createDataChannel("label", options)
						myRtcConnection.ondatachannel = (event) => {
							const receiveChannel = event.channel;
							receiveChannel.onmessage = (event) => {
								// got a message
							}
						}
					</code></pre>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myDataChannel.send( "Some data" );
					</code></pre>
				</section>
				<section>
					<h2>Connecting to another browser</h2>
					<p class="fragment">Need to meed at a signaling server</p>
					<p class="fragment">Does not tecnically need a signaling server</p>
					<p class="fragment">Can use some pidgeon with a memory stick</p>
					<p class="fragment">Suggest using WebSocket</p>
				</section>
				<section>
					Call some user connected to the same backend
					<p class="fragment">
						Create and send an offer (RTCSessionDescription)
					</p>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.createOffer().then(offer => {
							sendMessageToServer(offer, "User B");
							myRtcConnection.setLocalDescription(offer);
						}
					</code></pre>
					<aside class="notes" data-markdown>
						- A description of who you are, and what you support (your browser)
					</aside>
				</section>
				<section>
					The other user then receives this from the backend and creates an answer (RTCSessionDescription)
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.setRemoteDescription(offer);
						myRtcConnection.createAnswer((answer) => {
							sendMessageToServer(answer, "User A");
							myRtcConnection.setLocalDescription(answer);
						}
					</code></pre>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// on caller's side
						myRtcConnection.setRemoteDescription(answer);
					</code></pre>
				</section>
				<section>
					Then a series of ICE candiates are sent back and forth (RTCIceCandidate)
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						myRtcConnection.onicecandidate = (event) => {
							sendMessageToServer(event.candidate, "Other User");
						}
						// on the other client:
						myRtcConnection.addIceCandidate(new RTCIceCandidate(candidate))
					</code></pre>
					<aside class="notes" data-markdown>
						- For finding the shortest path between your two computers
						- Interactive Connectivity Establishment (ICE)
					</aside>
				</section>
				<section>
					Then each client attempts to connect to each other
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// Automagick
					</code></pre>
					<p class="fragment">
						Might fall back to TURN
					</p>
				</section>
				<section>
					Video conversation etc...
				</section>
				<section>
					<h2>
						Summary
					</h2>
					<ol>
						<li class="fragment">
							Shared backend
						</li>
						<li class="fragment">
							Video, sound, data
						</li>
						<li class="fragment">
							CreatePeerConnection with STUN (local)
						</li>
						<li class="fragment">
							Send offer, and receive answer
						</li>
						<li class="fragment">
							ICE candidates for mapping the network
						</li>
						<li class="fragment">
							Maybe fall back to TURN
						</li>
					</ol>
					<h2 class="fragment">
						Connected!
					</h2>
				</section>
			</section>
			<section>
				<section>
					<h3>The data channel</h3>
				</section>
				<section>
					Can send almost anything
				</section>
				<section>
					<h2>Examples</h2>
					<ul>
						<li class="fragment">Sending chat</li>
						<li class="fragment">Sending files</li>
						<li class="fragment">Sending state (game, redux, drawing, ...)</li>
						<li class="fragment">Sending screen</li>
						<li class="fragment">CDN</li>
					</ul>
				</section>
				<section>
					And no premission required (sidenote about safari)
				</section>
			</section>
			<section>
				<section>
					Let's dive into a few examples
				</section>
				<section>
					Sending chat
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// sender
						myDataChannel.send("Hello");

						// on the receiving side
						this.myRtcConnection.ondatachannel = (event) => {
							receiveChannel.onmessage = (message) => {
								// Display message
							};
						};
					</code></pre>
				</section>
				<section>
					Sending files
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						// sender
						const fileReader = new FileReader();
						const fileSlice = file.slice(offset, offset + chunckSize);
						fileReader.readAsArrayBuffer(fileSlice);
						fileReader.onload = (event) => {
							this.myDataChannel.send(event.target.result);
						}

						// on the receiving side
						incommingFileBuffer.push(arrayBuffer);

						// when done on the receiving side
						var recivedFile = new Blob(this.incommingFileBuffer); 
					</code></pre>
					<aside class="notes" data-markdown>
						- Break large files up into chunks (offset and chunckSize)
					</aside>
				</section>
				<section>
					<h3>Sharing screen</h3>
					<p class="fragment">
						New API (getUserMedia -> getDisplayMedia)
					</p>
					<pre class="fragment"><code class="TypeScript" data-trim contenteditable>
						navigator.getDisplayMedia({ video: true })
						.then(function(mediaStream) {
							...
						}
					</code></pre>
					<h3 class="fragment">Only supported in Edge</h3>
					<aside class="notes" data-markdown>
						- Comming to rest. Might already be out for some
						- Might miss target of chrome 70
					</aside>
				</section>
				<section>
					Sharing a game state (drawing app)
				</section>
			</section>
			<section>
				<section>
					Large Data Channel Messages
				</section>
				<section>
					EOR<br>
					End Of Record<br>
					Is the message complete, or partial?
					<aside class="notes" data-markdown>
						- Chromium ignores that flag and simply delivers the incomplete message
						- Partial ways arout it
					</aside>
				</section>
				<section>
					"Thanks to the new EOR feature Firefox now supports receiving up to 1 GiB messages."
					<aside class="notes" data-markdown>
						- was less than 64 KiB
						- Got unstable around here, suddenly closing the connection, or blocking all other data
						- Firefox is now ahead of Chrome
					</aside>
				</section>
				<section>
					Not higher as the entire object needs to fit into memory and 1gb is starting to become to high for some devices
					due to low ram
					<aside class="notes" data-markdown>
						And larger messages are easilier lost in transmission (and at a higher cost)
					</aside>
				</section>
				<section>
					Is backward compatiable
				</section>
			</section>
			<section>
				<section>
					<h3>Browser support</h3>
					<iframe style="width: 700px; height: 580px;" src="https://caniuse.com/#search=webrtc"></iframe>
					<aside class="notes" data-markdown>
						- Edge does not have the data channel

						- "Microsof is unhappy with the state of WebRTC and wants a bigger standard (Object RTC)"
						- MS wants more control
					</aside>
				</section>
				<section>
					<h3>Browser diference</h3>
					<table>
						<thead>
							<tr>
								<th>Browser</th>
								<th>Quirck</th>
							</tr>
						</thead>
						<tbody>
							<tr class="fragment">
								<td>Firefox</td>
								<td>Most up top date with the spec</td>
							</tr>
							<tr class="fragment">
								<td>Chrome</td>
								<td>Good, but behind FF</td>
							</tr>
							<tr class="fragment">
								<td>Safari</td>
								<td>Recent. Data channel issues (to be fixed)</td>
							</tr>
							<tr class="fragment">
								<td>iOS</td>
								<td>Only safari (comming to other browsers)</td>
							</tr>
							<tr class="fragment">
								<td>Android</td>
								<td>FF, Chrome and Samsung</td>
							</tr>
							<tr class="fragment">
								<td>Edge</td>
								<td>No data channel. getDisplayMedia. Object RTC</td>
							</tr>
							<tr class="fragment">
								<td>IE 11</td>
								<td>ðŸ˜‚</td>
							</tr>
						</tbody>
						<aside class="notes" data-markdown>
							- Safari initally refused data connection w/o video or audio. Reverted that decition
							- UC for Android has no support (from china)
							- Remember that all browser on iOS are just skins for safari
						</aside>
					</table>
				</section>
				<section>
					Safari and all the bugs
					NO DATA CHANNEL WITHOUT VIDEO?!?!
					"Safari fails to establish a connection here unless getUserMedia is called"
					"Contrary to Chrome and Firefox, we do not leak private IP addresses access unless camera or microphone access is
					also granted."
					<h1>TODO SHOT FROM IFRAME</h1>
					<iframe style="width: 700px; height: 580px;" src="https://bugs.webkit.org/show_bug.cgi?id=189503#c2"></iframe>
					<aside class="notes" data-markdown>
						- one of several data related bugs
						- (might have changes) could
						- Remember, Webkit/Appleâ€™s implementation is young
						- (might have changed) Webrtc only works insafari on ios, not in chrome on top of safari or webview

					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Security</h2>
					I read a 8k pice: "A Study of WebRTC Security"
					Don't bother, its really good (inlude screenshot)<br>
					The alternatives are less secure
					"If I wanted to hack you, WebRTC would be the last place Iâ€™d start."
					It is encrypted. By default. And thereâ€™s no way to remove that encryption from occurring
					Asks for Camera
					It gets updated every 6-8 weeks with your browser

					<aside class="notes" data-markdown>
						- "As a result of this strong focus on secure communication,
						WebRTC is currently regarded by some to be one of the most secure VoIP solutions out there"
						- WebRTC forbids unencrypted communication
						- IP problem can be solved by good VPN (but ip exposed by a lot of progs)
					</aside>
				</section>
				<section>
					<h2>Privacy</h2>
					Can use data channel without premission, but really no privacy issue exept for public IP
					"in Firefox 60, whenever you video-mute, your laptop or USB camera hardware light will now extinguish"
					<aside class="notes" data-markdown>
						- Scary to be seen. User NEEDS to know when thay are streaming video
					</aside>
				</section>
				<section>
					Webrtc and STUN gets your public IP. is that bad?
				</section>
			</section>
			<section>
				<section>
					How many connected users?
				</section>
				<section>
					The server-client model<br>
					<img class="stretch" data-src="media/csm.png">
				</section>
				<section>
					Peer to Peer<br>
					<img class="stretch" data-src="media/p2p.png">
				</section>
				<section>
					You can structure WebRTC data channel network as either, but easier with P2P
					As it is just data, you can realy it frougth a "host"
				</section>
				<section>
					Room size<br>
					<img class="stretch" data-src="media/complex.jpg">
					Stopping at 10 is a good place for video, more for data

					<aside class="notes" data-markdown>
						- Can get mor with a Selective Forwarding Unit. (back to client server model)
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h3>To send data reliably, or not</h3>
					Sending ordered or not. One is faser, one is reliable <br>
					Why send unreliable?
				</section>
				<section>
					<h1>Speed</h1>
					<aside class="notes" data-markdown>
						- Sending files and chan ureliable would be catastrofic
						- sending game starte unreliable cold be benefitical
						- UDP vs TCP
					</aside>
				</section>
			</section>
			<section>
				Debugging WebRTC
				<iframe style="width: 700px; height: 580px;" src="https://testrtc.com/"></iframe>
			</section>
			<section>
				Consider using WebRTC adapter (github.com/webrtchacks/adapter)
			</section>
			<section>
				<section>
					News in WebRTC
				</section>
				<section>
					WebRTC is a Candidate Recommendation (CR)! (21 June 2018)<br>
					Means it started to stabilise and will se wider and better support
				</section>
				<section>
					Transceiver <br>
					New (and optional) way of having more control over how media flows between clients<br>
					More control for more complexity
					Don't learn it utill you master the standard (and easie) way
					(as far as i know) it will remain optional and not become the standard
					Transceiver will allow you to distinguish between several incommong video streams
					Can start sending video befor negotiation has completed
					Only in FF for now, comming to rest
				</section>
				<section>
					AddStream is replaced by AddTrack as WebRTC now support multible streams (video/audio) from each user<br>
					Data channel has always supported multible, but they could force sending in sequence on large messages
				</section>
				<section>
					<h3 class="no-caps">RTCRtpTransceiver.direction</h3>
					<table>
						<thead>
							<tr>
								<th>State</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
							<tr class="fragment">
								<td>"sendrecv"</td>
								<td>Sending and reciving</td>
							</tr>
							<tr class="fragment">
								<td>"sendonly"</td>
								<td>Sending</td>
							</tr>
							<tr class="fragment">
								<td>"recvonly"</td>
								<td>Reciving</td>
							</tr>
							<tr class="fragment">
								<td>"inactive"</td>
								<td>Nothing/disabled</td>
							</tr>
						</tbody>
					</table>

				</section>
				<section>
					Unified Plan VS Plan B
					The fingt for how to send multible video streams
					<aside class="notes" data-markdown>
						- Unified Plan win (in FF)
						- Plan B lost (in chrome, will be replaced)
						- For sending multible video stresm like cameras and screens
					</aside>
				</section>
			</section>
			<section>
				<section>
					Just a few short ideas, there are MANY more usecases for sending data directly bvetween one or more browsers
				</section>
				<section>
					Got sad when you relised that the broadcast API is limited to a browser? <br>
					Use the data channel to link up more web browser on the same machene!
				</section>
				<section>
					Allow you to view this prez live on nour phone as i present? WEBRTC!
				</section>
				<section>
					Offloading data transmition to the frontend
					<br>
					Servers are (relativly) expencive
					<br>
					Using WebRTC offloads a lot of bandwith off the server
					<aside class="notes" data-markdown>
						- Can do far bigger, faster and more reliable data transfers between clients as server is not overloaded
					</aside>
				</section>
				<section>
					(call to action)<br>
					Webrtc is a buldingblock for the web of tomorrow. You will need it, either for video or data, or both. <br>
					We are aproaching av ever more connected future and WebRTC will help create that future
				</section>
			</section>
			<section>
				<h3>Chrome is killing background tabs</h3>
				(murder img?)
				There is hope!
				WebRTC connections are (mostly exempted)
				<aside class="notes" data-markdown>
					- Applications with real-time connections (WebSockets and WebRTC), to avoid closing these connections by timeout.
					The run-timers-once-a-second rule is still applied in these cases.
					- Applications playing audio are considered foreground and arenâ€™t throttled. (webRTC with audio)
				</aside>
			</section>
			<section>
				Remember, it's gratis
				(exept for signaling and turn)
				"in almost all cases, using WebRTC will cost you less and get you there faster than the alternatives"
			</section>
			<section>
				Remember Webrtc is a tool, not a solution
			</section>
			<section>
				<h3>Quick example of webRTC in action?</h3>
				apper.in
				<aside class="notes" data-markdown>
					- Norwegian company, originale by Telenor, now sold to Videonor
				</aside>
			</section>
			<section>
				https://blog.mozilla.org/webrtc/<br>
				<img class="webrtc-logo-img" src="media/ffWebrtcblog.JPG">
			</section>
			<section>
				Questions
			</section>
			<section>
				This page is unintentionally left blank
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			history: true,
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>